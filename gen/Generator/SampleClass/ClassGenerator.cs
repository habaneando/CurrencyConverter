namespace Generator;

[Generator]
internal class ClassGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax,
                transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(static m => m is not null);

        var compilation = context.CompilationProvider
            .Combine(provider.Collect());

        context.RegisterSourceOutput(compilation,static (spc, source) =>
            Execute(spc, source.Left, source.Right));
    }

    private static void Execute(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> typeList)
    {

        if (false)
        { 
            // Example error reporting
            var diagnosticDescriptor = new DiagnosticDescriptor(
                id: "SG0001",
                title: "Title Sample",
                messageFormat: "Message Sample",
                category: "Category",
                defaultSeverity: DiagnosticSeverity.Info,
                isEnabledByDefault: true);

            context.ReportDiagnostic(
                Diagnostic.Create(diagnosticDescriptor, Location.None));
        }

        var sourceName = "SampleClass.g.cs";

        var source = @"
            // <auto-generated/>
            namespace GeneratedCode
            { 
                public class SampleClass3
                {
                    public void DoSomething() { }
                }
            }";

        context.AddSource(sourceName, source);
    }
}
